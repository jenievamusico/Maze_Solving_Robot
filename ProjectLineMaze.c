#pragma config(Sensor, S1,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//initializing variables and structs
#define size sizeof(directPathArray)/sizeof(directPathArray[0])


int initalRobotHeading = 1;          // Direction Robot is Facing: N=0; E=1; S=2; W=3;
int initalRow = 2;                 //Starting Row Location
int initalColumn = 0;                 //Starting Column Location
int finalRow = 4;                //Target Row Location
int finalColumn = 8;                //Target Column Location
int currentRobotHeading = initalRobotHeading;
int robRow = initalRow;
int robCol = initalColumn;
int bestIncrement = 0;
int physIncrement = 0;
int physicalCol = initalColumn;
int physicalRow = initalRow;
int columnCellValue = 380;  //decoder value for the side Length of each Square Cell
int numDirec = 0;

//Saved positions
char directPathArray[200];
int locationArray = 0;
int gyroArray[100];

//initializing the size of the maze (rows and columns) with respect to the size of the brick screen
const int numOfRows = 7;
const int numOfCols = 9;
float displayWidth = 177;
float displayHeight = 127;
float	cellWidth = displayWidth/8;
float	cellHeight = displayHeight/6;


struct mazeCell{ //Structre with all the possible paths (lines) for each cell
	int NorthLine;
	int EastLine;
	int SouthLine;
	int WestLine;
}struct mazeCell Maze[numOfRows][numOfCols];

//FUNCTION PROTOTYPES
void initializeMaze();
void defineMazeLines();
void drawMazeOnScreen();
void refreshScreen();
void displayBot();
void gyroRotationsRight();
void gyroRotationsLeft();
void goFwd();
void rightLineMazeSolver();
void mostEfficentPath(char *arr);
void lineTracking();
void physicalRobotLineTracking(char *arr);
void gyroRotations(int *gyroArray, int currentCellPos);
void LocSave(int loc);
void shortestPathArrLength();
void shortestPathDisplay(char* directPathArray);


task main() { //Run all the functions in the Main Code
	refreshScreen();
	initializeMaze();
	defineMazeLines();
	drawMazeOnScreen();
	rightLineMazeSolver();
	mostEfficentPath(directPathArray);
	physicalRobotLineTracking(directPathArray);
	shortestPathArrLength();

	//reset
	currentRobotHeading = initalRobotHeading;
	robRow = initalRow;
	robCol = initalColumn;

	shortestPathDisplay(directPathArray);

	resetGyro(gyroSensor); //reset Gyro Value

	for(int i = 0; i < numDirec; i++){ //Run the movement functions for the length of the array of the shortest path taken
		lineTracking();
		gyroRotations(gyroArray, i);
	}

	//stop the robot
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);

}



//CODE FOR ALL THE FUNCTIONS (BELOW)


// GENERATING MAZE STRUCTURES AND DISPLAY

void initializeMaze(){//Initialize all the maze cells

	for (int row = 0; row < numOfRows; row++){
		for (int col = 0; col < numOfCols; col++){
			Maze[row][col].NorthLine = 0;
			Maze[row][col].EastLine = 0;
			Maze[row][col].SouthLine = 0;
			Maze[row][col].WestLine = 0;
		}
	}
}



void defineMazeLines(){ //Define all the maze lines from row 0 until row 6

	// row 0
	Maze[0][1].EastLine = Maze[0][2].WestLine = 1;
	Maze[0][2].NorthLine = 1;
	Maze[0][2].EastLine = Maze[0][3].WestLine = 1;
	Maze[0][3].EastLine = Maze[0][4].WestLine = 1;
	Maze[0][6].EastLine = Maze[0][7].WestLine = 1;
	Maze[0][7].NorthLine = 1;
	Maze[0][8].NorthLine = 1;

	// row 1
	for(int i = 0; i < 8; i++){
		Maze[1][i].EastLine = Maze[1][i+1].WestLine = 1;
	}
	Maze[1][2].NorthLine = Maze[1][2].SouthLine = 1;
	Maze[1][7].NorthLine = Maze[1][7].SouthLine = 1;
	Maze[1][8].SouthLine = 1;

	// row 2
	Maze[2][0].EastLine = Maze[2][1].WestLine = 1;
	Maze[2][1].NorthLine = 1;
	Maze[2][2].NorthLine = Maze[2][2].SouthLine = 1;
	Maze[2][3].NorthLine = 1;
	Maze[2][3].EastLine = Maze[2][4].WestLine = 1;
	Maze[2][4].EastLine = Maze[2][5].WestLine = 1;
	Maze[2][5].NorthLine = 1;
	Maze[2][5].EastLine = Maze[2][6].WestLine = 1;
	Maze[2][6].NorthLine = 1;
	Maze[2][7].NorthLine = Maze[2][7].SouthLine = 1;

	// row 3
	Maze[3][1].SouthLine = 1;
	Maze[3][1].EastLine = Maze[3][2].WestLine = 1;
	Maze[3][2].NorthLine = Maze[3][2].SouthLine = 1;
	Maze[3][2].EastLine = Maze[3][3].WestLine = 1;
	Maze[3][3].SouthLine = 1;
	Maze[3][4].NorthLine = 1;
	Maze[3][5].SouthLine = 1;
	Maze[3][6].NorthLine = Maze[3][6].SouthLine = 1;
	Maze[3][7].NorthLine = Maze[3][7].SouthLine = 1;

	// row 4
	for(int i = 0; i < 5; i++){
		Maze[4][i].EastLine = Maze[4][i+1].WestLine = 1;
	}
	Maze[4][2].NorthLine = Maze[4][2].SouthLine = 1;
	Maze[4][4].NorthLine = Maze[4][4].SouthLine = 1;
	Maze[4][6].NorthLine = Maze[4][6].SouthLine = 1;
	Maze[4][7].NorthLine = Maze[4][7].SouthLine = 1;
	Maze[4][7].EastLine = Maze[4][8].WestLine = 1;

	// row 5
	Maze[5][1].NorthLine = 1;
	Maze[5][1].EastLine = Maze[5][2].WestLine = 1;
	Maze[5][2].NorthLine = Maze[5][2].SouthLine = 1;
	Maze[5][4].SouthLine = 1;
	Maze[5][4].EastLine = Maze[5][5].WestLine = 1;
	Maze[5][5].NorthLine = 1;
	Maze[5][6].NorthLine = Maze[5][6].SouthLine = 1;
	Maze[5][7].NorthLine = Maze[5][7].SouthLine = 1;

	// row 6
	Maze[6][0].EastLine = Maze[6][1].WestLine = 1;
	Maze[6][1].SouthLine = 1;
	Maze[6][2].SouthLine = 1;
	Maze[6][5].SouthLine = 1;
	Maze[6][6].SouthLine = 1;
	Maze[6][7].SouthLine = 1;
}


void drawMazeOnScreen(){ //Simulate (draw) the maze on the brick screen based on the lines defined of each cell
	for (int row = 0; row < numOfRows; row++){
		for (int col = 0; col < numOfCols; col++){
			if(Maze[row][col].NorthLine == 1){
				draWestLine(cellWidth*col, cellHeight*row, cellWidth*col, cellHeight*(row+1));
			}
			if(Maze[row][col].EastLine == 1){
				draWestLine(cellWidth*col, cellHeight*row, cellWidth*(col+1), cellHeight*row);
			}
			if(Maze[row][col].SouthLine == 1){
				draWestLine(cellWidth*col, cellHeight*row, cellWidth*col, cellHeight*(row-1));
			}
			if(Maze[row][col].WestLine == 1){
				draWestLine(cellWidth*col, cellHeight*row, cellWidth*(col-1), cellHeight*row);
			}
		}
	}
}

//VIRTUAL ROBOT

void displayBot(){ //Display robot movement on brick screen
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;
	if(robCol==0){
		RobotXpixelPos=2;
	}
	else{
		RobotXpixelPos=robCol*cellWidth-2;
	}
	if(robRow==0){
		RobotYpixelPos=2;
	}
	else{
		RobotYpixelPos=robRow*cellHeight+2;
	}
	switch(currentRobotHeading){
	case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^"); wait1Msec(1); // North
		break;
	case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">"); wait1Msec(1); // East
		break;
	case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V"); wait1Msec(1); // South
		break;
	case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<"); wait1Msec(1); // West
		break;
	default: break;
	}
}

void rightLineMazeSolver(){ //Right "Line" follow algorithm is used to solve the maze

	while((robRow != finalRow) || (robCol != finalColumn)){ //Loop until target location is reached

		switch(currentRobotHeading){ //Switch statement for the directions the robot is facing
		case 0:																						//North
			if(Maze[robRow][robCol].EastLine == 1){ //If a line is to the right of the direction the robot is facing, turn right
				gyroRotationsRight();
				displayBot();
				break;
			}
			else if (Maze[robRow][robCol].NorthLine == 1){ //If there is no line to the right but there is a line in front, go forward
				break; //dont turn
			}
			else if (Maze[robRow][robCol].WestLine == 1){ //If there is no line to its right or front, turn left
				gyroRotationsLeft();
				displayBot();
				break;
			}

			else if (Maze[robRow][robCol].SouthLine == 1){ //If there is no line for any direction, turn around
				gyroRotationsLeft();
				gyroRotationsLeft();
				displayBot();
				break;
			}
			break;

		case 1:																						//East
			if(Maze[robRow][robCol].SouthLine == 1){
				gyroRotationsRight();
				displayBot();
				break;
			}
			else if (Maze[robRow][robCol].EastLine == 1){
				break;
			}
			else if (Maze[robRow][robCol].NorthLine == 1){
				gyroRotationsLeft();
				displayBot();
				break;
			}
			else if (Maze[robRow][robCol].WestLine == 1){
				gyroRotationsLeft();
				gyroRotationsLeft();
				displayBot();
				break;
			}
			break;

		case 2:																						//South
			if(Maze[robRow][robCol].WestLine == 1){
				gyroRotationsRight();
				displayBot();
				break;
			}
			else if (Maze[robRow][robCol].SouthLine == 1){
				break;
			}
			else if (Maze[robRow][robCol].EastLine == 1){
				gyroRotationsLeft();
				displayBot();
				break;
			}
			else if (Maze[robRow][robCol].NorthLine == 1){
				gyroRotationsLeft();
				gyroRotationsLeft();
				displayBot();
				break;
			}
			break;


		case 3:                                                                                      //West
			if(Maze[robRow][robCol].NorthLine == 1){
				gyroRotationsRight();
				displayBot();
				break;
			}
			else if (Maze[robRow][robCol].WestLine == 1){
				break;
			}
			else if (Maze[robRow][robCol].SouthLine == 1){
				gyroRotationsLeft();
				displayBot();
				break;
			}
			else if (Maze[robRow][robCol].EastLine == 1){
				gyroRotationsLeft();
				gyroRotationsLeft();
				displayBot();
				break;
			}
			break;

		default: break;
		}
		goFwd();
		displayBot();
		LocSave(locationArray);
		locationArray++;
	}

	for(int i = 0; i < 3; i++){ //Display "Maze solved" once finidng the path solution
		eraseDisplay();
		sleep(100);
		displayCenteredTextLine(3,"Maze Solved");
		sleep(100);
	}
	eraseDisplay();
}

void LocSave(int loc){ //Save the location of the longest path taken, in the array
	if(currentRobotHeading == 0){
		directPathArray[loc] = 'N'; //North
	}
	if(currentRobotHeading == 1){
		directPathArray[loc] = 'E'; //East
	}
	if(currentRobotHeading == 2){
		directPathArray[loc] = 'S'; //South
	}
	if(currentRobotHeading == 3){
		directPathArray[loc] = 'W'; //West
	}
}


void gyroRotationsRight(){ //turn the robot right
	if (currentRobotHeading < 3){
		currentRobotHeading++;
	}
	else currentRobotHeading=0;
}


void gyroRotationsLeft(){ //turn the robot left
	if (currentRobotHeading > 0){
		currentRobotHeading--;
	}
	else currentRobotHeading=3;
}


void goFwd(){ //Robot moves to the line infront of it in the display depending on direction it is facing
	wait1Msec(10); // waste some time
	if (currentRobotHeading==0) { //go forward North
		robRow++;
	}
	else if (currentRobotHeading==1) { //go forward East
		robCol++;
	}
	else if (currentRobotHeading==2) { //go forward South
		robRow--;
	}
	else if (currentRobotHeading==3) { //go forward West
		robCol--;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
	refreshScreen();
}



void refreshScreen(){ //Refresh screen on display
	eraseDisplay();
	defineMazeLines();
	drawMazeOnScreen();
	displayBot();
}

// displays robot completing shortest path on screen
void shortestPathDisplay(char* directPathArray){
	goFwd();
	for(int i = 0; i < numDirec; i++){
		switch(directPathArray[i]){
		case 'N':// Facing North
			if(directPathArray[i+1] == 'N'){
				goFwd();
				displayBot();
				//	drive Straight
			}
			if(directPathArray[i+1] == 'E'){
				gyroRotationsRight();
				displayBot();
				goFwd();
				displayBot();
				//   right Line Tracking
			}
			if(directPathArray[i+1] == 'W'){
				gyroRotationsLeft();
				displayBot();
				goFwd();
				displayBot();
				//		left Line Tracking
			}
			break;
		case 'E':// Facing East
			if(directPathArray[i+1] == 'E'){
				goFwd();
				displayBot();//	drive Straight
			}
			if(directPathArray[i+1] == 'S'){
				gyroRotationsRight();
				displayBot();
				goFwd();
				displayBot();//   right Line Tracking
			}
			if(directPathArray[i+1] == 'N'){
				gyroRotationsLeft();
				displayBot();
				goFwd();
				displayBot();//		left Line Tracking
			}
			break;
		case 'S': // Face South
			if(directPathArray[i+1] == 'S'){
				goFwd();
				displayBot();//	drive Straight
			}
			if(directPathArray[i+1] == 'W'){
				gyroRotationsRight();
				displayBot();
				goFwd();
				displayBot(); //   right Line Tracking
			}
			if(directPathArray[i+1] == 'E'){
				gyroRotationsLeft();
				displayBot();
				goFwd();
				displayBot();//		left Line Tracking
			}
			break;
		case 'W': // Face West
			if(directPathArray[i+1] == 'W'){
				goFwd();
				displayBot();//	drive Straight
			}
			if(directPathArray[i+1] == 'N'){
				gyroRotationsRight();
				displayBot();
				goFwd();
				displayBot();//   right Line Tracking
			}
			if(directPathArray[i+1] == 'S'){
				gyroRotationsLeft();
				displayBot();
				goFwd();
				displayBot();//		left Line Tracking
			}
			break;
		default: break;
		}
	}

}


//PHYSICAL ROBOT

void mostEfficentPath(char *arr){ //From the path taken, turn it into the shortest possible solution for the maze
	int value1, value2;
	int increment = 0;

	for(int y = 0;y <= 50; y++){	//Simplify over the course of 50 loops
		for(int i = 0;i < size-1; i++){//Compare 2 values that are one after another, from path, to check if they are redundant
			value1 = arr[i];
			value2 = arr[i+1];

			if((abs(value2-value1) == 18) || (abs(value2-value1) == 5)){ 	//Save the redundant values
				arr[i] = 0;
				arr[i+1] = 0;
			}
		}

		for(int i = 0;i < size;i++){	//Shift all values to remove the zeros (unnecessary paths)
			if(arr[i] != 0){
				arr[increment] = arr[i];
				increment++;
			}
		}

		for(int i = size; i >= increment; i--){ //Set all values outside of saved path to 0
			arr[i] = 0;
		}
		//Reset variables for next loop of new array
		increment = 0;
	}
}



void physicalPos(){ // Positions of the robot
	switch(directPathArray[physIncrement]){ //Depending on the arr using case structure we can determine whether we are travelling down a row or column
	case 'N': // North
		physicalRow++;
		break;
	case 'E': // East
		physicalCol++;
		break;
	case 'S': // South
		physicalRow--;
		break;
	case 'W': // West
		physicalCol--;
		break;
	default: break;
	}
	physIncrement++;
}

void gyroRotations(int *gyroArray, int currentCellPos){

	resetGyro(gyroSensor);

	if(gyroArray[currentCellPos] < 0){
		while(getGyroDegrees(gyroSensor) >= gyroArray[currentCellPos]){ // Set gyro speeds for turns
			setMotorSpeed(leftMotor, 20);
			setMotorSpeed(rightMotor, -16);
		}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
	}

	if(gyroArray[currentCellPos] > 0){
		while(getGyroDegrees(gyroSensor) < gyroArray[currentCellPos]){
			setMotorSpeed(leftMotor, -16);
			setMotorSpeed(rightMotor, 20);
		}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
	}

	if(gyroArray[currentCellPos] == 0){
		//do nothing
	}
	sleep(1000);

}

// Line tracking Physical Robot (with Color sensor )

void lineTracking() {

	physicalPos();
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	while(getMotorEncoder(leftMotor) < columnCellValue){
		setMotorSpeed(leftMotor, 5);
		setMotorSpeed(rightMotor, 10);		//drift left

		if(physicalCol > 4){    //follow the yellow line

			while(getColorReflected(colorSensor) > 15){
				setMotorSpeed(leftMotor, 25);
				setMotorSpeed(rightMotor, 15);
			}
		}

		if(physicalCol < 5){ //follow black line

			while(getColorReflected(colorSensor) < 8){
				setMotorSpeed(leftMotor, 20);
				setMotorSpeed(rightMotor, 0);			//drift right
			}
		}

	}
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	if(physicalCol > 4){

		setMotorTarget(leftMotor, columnCellValue - 145, 20);
		setMotorTarget(rightMotor, columnCellValue - 145, 20);
		waitUntilMotorStop(leftMotor);
	}

	if(physicalCol < 5){

		setMotorTarget(leftMotor, columnCellValue - 155, 20);
		setMotorTarget(rightMotor, columnCellValue - 155, 20);
		waitUntilMotorStop(leftMotor);

	}
}

// Switch Statements for Line tracking

void physicalRobotLineTracking(char *arr){
	for(int i = 0; i < size; i++){

		switch(arr[i]){


		case 'N':
			if(arr[i+1] == 'N'){
				gyroArray[i] = 0; //	drive Straight
			}
			if(arr[i+1] == 'E'){
				gyroArray[i] = 90; //   right Line Tracking
			}
			if(arr[i+1] == 'W'){
				gyroArray[i] = -90; //		left Line Tracking
			}
			break; // Facing North
		case 'E':
			if(arr[i+1] == 'E'){
				gyroArray[i] = 0; //	drive Straight
			}
			if(arr[i+1] == 'S'){
				gyroArray[i] = 90; //   right Line Tracking
			}
			if(arr[i+1] == 'N'){
				gyroArray[i] = -90;  //		left Line Tracking
			}
			break; // Facing East
		case 'S':
			if(arr[i+1] == 'S'){
				gyroArray[i] = 0; //	drive Straight
			}
			if(arr[i+1] == 'W'){
				gyroArray[i] = 90; //   right Line Tracking
			}
			if(arr[i+1] == 'E'){
				gyroArray[i] = -90; //		left Line Tracking
			}
			break; // Face South
		case 'W':
			if(arr[i+1] == 'W'){
				gyroArray[i] = 0; //	drive Straight
			}
			if(arr[i+1] == 'N'){
				gyroArray[i] = 90; //   right Line Tracking
			}
			if(arr[i+1] == 'S'){
				gyroArray[i] = -90;	//		left Line Tracking
			}
			break; // Face West
		default: break;
		}
	}
}


void shortestPathArrLength(){ // find the array length of the shortest path
	for(int i = 0; i < size; i++){
		if(directPathArray[i] != 0){
			numDirec++;
		}
	}
}
